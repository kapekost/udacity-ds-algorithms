## Problem 1

First step was to add a dictionary for the items to cache
- this allowed me to hook in the logic when to add / remove items from the cache
- enqueue and dequeue function to manage the state of the queue, 
this allows us to change the type/logic of caching, just by simply adjusting the queue/dequeue functions

- we want to keep the most recently accessed element in the cache, 
for this reason I thought to start aligning the order within the queue swapping items
but that would increase the Complexity

I found good idea to keep an array of keys separate to hold the order. 
since the queue is a dictionary (Set) it doesn't hold duplicates already
so the only addition in the logic would be to remove an existing key from this new list,
and push to the first place the same new value. 
```      
if(index in self.list_of_keys):
    self.list_of_keys.remove(index)
self.list_of_keys.append(index)
```
lastly I needed to attach in the get() function the priority of that key to come back to first most recently used

Space

- for the dictionary, which can get as many as the capacity, and the key:values that it holds.
in our current samples it holds values as integers.
- for the array of the keys, again same size as the capacity and integers for single values


Complexity 

- dequeue:
O(n) for both removing the key form the array and the object from the Cache Set
Complexity => O(n)

- enqueue
we add a value in the Set (O(1))
if we find a key in the list of keys, we remove it (O(n)) 
and then (+)
we append the index in the list of keys (O(n))
Complexity => O(n)

- get
we do a lookup O(n) and if we hit a result we do an enqueue (O(n)) for that one value
Complexity => O(n)

- index
just reassigns and returns the value
Complexity => O(1)

- set
performs a get(), O(n)
in case of a miss we do either an enqueue() (O(n)) or dequeue() (O(n)) followed by a set() (O(n))
Complexity => O(n)


## Problem 2

Starting from the root directory(where the program runs) we look for the given folder

print(f"c files: {file_explorer.find_files('.c', 'testdir')}")

for that directory we:
- loop through the listed files:
    for each file: (O(1))
    - if it's a file we check the suffix (string lookup) (O(1))
    - add in list (O(1))
    for each folder: (O(1))
    - if it's a folder we call this function again [recursive] (O(n))

Space:
    we use
    - a list for the files we find in a directory (+ subdirectories)
    - a smaller list for the results (files we were looking for)

Complexity:
Complexity => O(n)
